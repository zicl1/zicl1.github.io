<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>2022年07月07日 | Zichen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ASP .NET Core 3.0是做Web开发的框架。 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1c441167KQ 官网：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;aspnet&#x2F;core&#x2F;migration&#x2F;proper-to-2x&#x2F;?view&#x3D;aspnetcore-2.2 官网：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn">
<meta property="og:type" content="article">
<meta property="og:title" content="2022年07月07日">
<meta property="og:url" content="https://zicl1.github.io/2022/07/07/2022-07-07/index.html">
<meta property="og:site_name" content="Zichen">
<meta property="og:description" content="ASP .NET Core 3.0是做Web开发的框架。 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1c441167KQ 官网：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;aspnet&#x2F;core&#x2F;migration&#x2F;proper-to-2x&#x2F;?view&#x3D;aspnetcore-2.2 官网：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/kestrel-to-internet2.pngview=aspnetcore-2.2">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/kestrel-to-internet.pngview=aspnetcore-2.2">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/2022-07-07/httpsys-to-internet.pngview=aspnetcore-2.2">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/2022-07-07/httpsys-to-internal.pngview=aspnetcore-2.2">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707144453253.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707145341044.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707155750681.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707155932350.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707162507544.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707172500003.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707172526886.png">
<meta property="og:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/image-20220707172625707.png">
<meta property="article:published_time" content="2022-07-07T12:00:00.000Z">
<meta property="article:modified_time" content="2023-09-30T13:34:58.327Z">
<meta property="article:author" content="Zichen">
<meta property="article:tag" content="Life">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zicl1.github.io/2022/07/07/2022-07-07/kestrel-to-internet2.pngview=aspnetcore-2.2">
  
    <link rel="alternate" href="/atom.xml" title="Zichen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?786cc850f704e5c91f9db88eaa7e7798";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zichen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zicl1.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2022-07-07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/07/2022-07-07/" class="article-date">
  <time datetime="2022-07-07T12:00:00.000Z" itemprop="datePublished">2022-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2022年07月07日
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ASP-NET-Core-3-0"><a href="#ASP-NET-Core-3-0" class="headerlink" title="ASP .NET Core 3.0"></a>ASP .NET Core 3.0</h2><p>是做Web开发的框架。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c441167KQ">https://www.bilibili.com/video/BV1c441167KQ</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/migration/proper-to-2x/?view=aspnetcore-2.2">https://docs.microsoft.com/zh-cn/aspnet/core/migration/proper-to-2x/?view=aspnetcore-2.2</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/startup?view=aspnetcore-5.0">https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/startup?view=aspnetcore-5.0</a></p>
<h3 id="Startup-cs"><a href="#Startup-cs" class="headerlink" title="Startup.cs"></a>Startup.cs</h3><p><code>Startup</code> 必须包含 <code>Configure</code> 方法。</p>
<span id="more"></span>

<p>使用<code>Startup</code> (<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.hosting.ihostbuilder">IHostBuilder</a>) 时，只能将以下服务类型注入 <code>Startup</code> 构造函数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.hosting.iwebhostenvironment">IWebHostEnvironment</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.hosting.ihostenvironment">IHostEnvironment</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a></li>
</ul>
<p>在调用 <code>Configure</code> 方法之前，大多数服务都不可用。</p>
<pre><code class="c#">public Startup(IConfiguration configuration)
&#123;//注入IConfiguration
    Configuration = configuration;
&#125;

public IConfiguration Configuration &#123; get; &#125;
</code></pre>
<h4 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h4><p>创建应用的请求处理管道</p>
<p>请求管道中的每个中间件组件负责调用管道中的下一个组件，或在适当情况下使链发生短路。</p>
<pre><code class="c#">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
&#123;
    if (env.IsDevelopment())
    &#123;
        app.UseDeveloperExceptionPage();
    &#125;

    app.Run(async (context) =&gt;
    &#123;
        await context.Response.WriteAsync(&quot;Hello World!&quot;);
    &#125;);
&#125;
</code></pre>
<h4 id="ConfigureServices"><a href="#ConfigureServices" class="headerlink" title="ConfigureServices"></a>ConfigureServices</h4><p>配置应用的服务。 服务是一个提供应用功能的可重用组件。 在 中注册服务，并通过<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0">依赖关系注入 (DI)</a> 或 在整个应用中使用服务。</p>
<p>将服务添加到服务容器，使其在应用和 <code>Configure</code> 方法中可用。 服务通过<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">依赖关系注入</a>或 进行解析。</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    
&#125;
</code></pre>
<h3 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h3><p>在构建应用<code>Startup</code>时指定 <code>Startup</code> 类。 通常通过在主机生成器上调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestartup"><code>WebHostBuilderExtensions.UseStartup/&lt;TStartup&gt;</code></a> 方法来指定 <code>Startup</code> 类：</p>
<pre><code class="c#">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<h3 id="appsettings-json"><a href="#appsettings-json" class="headerlink" title="appsettings.json"></a>appsettings.json</h3><p>ASP.NET Core 可以将应用程序的配置数据存储在任何文件中，并可在启动中间件的过程中加载它们。 项目模板中使用的默认文件是 <code>appsettings.json</code></p>
<pre><code class="c#">&#123;
  &quot;Logging&quot;: &#123;
    &quot;LogLevel&quot;: &#123;
      &quot;Default&quot;: &quot;Warning&quot;
    &#125;
  &#125;,
  &quot;AllowedHosts&quot;: &quot;*&quot;
&#125;
</code></pre>
<p>将此文件加载到应用程序内部的 <code>IConfiguration</code> 实例中完成以下操作 <code>Startup.cs</code>：</p>
<pre><code class="c#">using Microsoft.Extensions.Configuration;

public Startup(IConfiguration configuration)
&#123;
    Configuration = configuration;
&#125;

public IConfiguration Configuration &#123; get; &#125;
</code></pre>
<p>应用读取 <code>Configuration</code> 来获得这些设置：</p>
<pre><code class="c#">string userName = Configuration.GetSection(&quot;AppConfiguration&quot;)[&quot;UserName&quot;];
string password = Configuration.GetSection(&quot;AppConfiguration&quot;)[&quot;Password&quot;];
</code></pre>
<p>//==TODO== </p>
<p>此方法有扩展项，它们可使此过程更加可靠，例如使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2">依存关系注入</a> (DI) 来加载使用这些值的服务。 DI 方法提供了一组强类型的配置对象。</p>
<pre><code class="c#">// Assume AppConfiguration is a class representing a strongly-typed version of AppConfiguration section
services.Configure&lt;AppConfiguration&gt;(Configuration.GetSection(&quot;AppConfiguration&quot;));
</code></pre>
<h3 id="依赖关系注入"><a href="#依赖关系注入" class="headerlink" title="依赖关系注入"></a>依赖关系注入</h3><p>ASP.NET Core 支持依赖关系注入 (DI) 软件设计模式，这是一种在类及其依赖关系之间实现<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion">控制反转 (IoC)</a> 的技术。</p>
<p>优点：</p>
<ol>
<li>使用接口或基类将依赖关系实现抽象化。</li>
<li>在服务容器中注册依赖关系。ASP.NET Core 提供了一个内置的服务容器 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/system.iserviceprovider">IServiceProvider</a>。 服务通常已在应用的 <code>Startup.ConfigureServices</code> 方法中注册。</li>
<li>将服务注入到使用它的类的构造函数中。框架负责创建依赖关系的实例，并在不再需要时将其释放。</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><code>IMyDependency</code>接口：</p>
<pre><code class="c#">public interface IMyDependency
&#123;
    void WriteMessage(string message);
&#125;
</code></pre>
<p>此接口由具体类型 <code>MyDependency</code> 实现：</p>
<pre><code class="c#">public class MyDependency : IMyDependency
&#123;
    public void WriteMessage(string message)
    &#123;
        Console.WriteLine($&quot;MyDependency.WriteMessage Message: &#123;message&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>使用具体类型 <code>MyDependency</code> 注册 <code>IMyDependency</code> 服务。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped">AddScoped</a> 方法使用范围内生存期（单个请求的生存期）注册服务。</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    services.AddScoped&lt;IMyDependency, MyDependency&gt;();

    //services.AddRazorPages();
&#125;
</code></pre>
<p>请求 <code>IMyDependency</code> 服务并用于调用 <code>WriteMessage</code> 方法：</p>
<pre><code class="c#">public class Index2Model : PageModel
&#123;
    private readonly IMyDependency _myDependency;

    public Index2Model(IMyDependency myDependency)
    &#123;
        _myDependency = myDependency;            
    &#125;

    public void OnGet()
    &#123;
        _myDependency.WriteMessage(&quot;Index2Model.OnGet&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="扩展方法注入"><a href="#扩展方法注入" class="headerlink" title="扩展方法注入"></a>扩展方法注入</h4><p>演示如何使用扩展方法 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions.adddbcontext">AddDbContext</a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.dependencyinjection.identityservicecollectionuiextensions.adddefaultidentity">AddDefaultIdentity</a> 将其他服务添加到容器中：</p>
<p>可以将相关的注册组移动到扩展方法以注册服务。 例如，配置服务会被添加到以下类中：</p>
<pre><code class="c#">using ConfigSample.Options;
using Microsoft.Extensions.Configuration;

namespace Microsoft.Extensions.DependencyInjection
&#123;
    public static class MyConfigServiceCollectionExtensions
    &#123;
        public static IServiceCollection AddConfig(
             this IServiceCollection services, IConfiguration config)
        &#123;
            services.Configure&lt;PositionOptions&gt;(
                config.GetSection(PositionOptions.Position));
            services.Configure&lt;ColorOptions&gt;(
                config.GetSection(ColorOptions.Color));

            return services;
        &#125;
        
        public static IServiceCollection AddMyDependencyGroup(
             this IServiceCollection services, IConfiguration config)
        &#123;
            return services;
        &#125;
    &#125;
&#125;
</code></pre>
<p>剩余的服务会在类似的类中注册。 下面的 <code>ConfigureServices</code> 方法使用新扩展方法来注册服务：</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    services.AddConfig(Configuration)
        .AddMyDependencyGroup();
&#125;
</code></pre>
<p>每个 <code>services.Add&#123;GROUP_NAME&#125;</code> 扩展方法添加并可能配置服务。</p>
<h4 id="生存期和注册选项"><a href="#生存期和注册选项" class="headerlink" title="生存期和注册选项"></a>生存期和注册选项</h4><p>记录器输出显示：</p>
<ul>
<li>暂时性对象始终不同。 <code>IndexModel</code> 和中间件中的临时 <code>OperationId</code> 值不同。</li>
<li>范围内对象对给定请求而言是相同的，但在每个新请求之间不同。</li>
<li>单一实例对象对于每个请求是相同的。</li>
</ul>
<p>范围内服务必须在 <code>InvokeAsync</code> 方法中进行解析：</p>
<pre><code class="c#">public async Task InvokeAsync(HttpContext context,
    IOperationScoped scopedOperation)
&#123;
    _logger.LogInformation(&quot;Transient: &quot; + _transientOperation.OperationId);
    _logger.LogInformation(&quot;Scoped: &quot;    + scopedOperation.OperationId);
    _logger.LogInformation(&quot;Singleton: &quot; + _singletonOperation.OperationId);

    await _next(context);
&#125;
</code></pre>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-2.2">Kestrel 服务器</a>是默认跨平台 HTTP 服务器实现。 Kestrel 提供了最佳性能和内存利用率，但它没有 HTTP.sys 中的某些高级功能。 有关详细信息，请参阅下一部分中的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/?view=aspnetcore-2.2&tabs=windows#korh">Kestrel 与 HTTP.sys</a>。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/iis/get-started/introduction-to-iis/introduction-to-iis-architecture">IIS</a> 或 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/iis/extensions/introduction-to-iis-express/iis-express-overview">IIS Express</a> 时，应用会在以下其中一个进程中运行：</p>
<ul>
<li>在使用 IIS HTTP 服务器的 IIS 工作进程（<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/?view=aspnetcore-2.2&tabs=windows#hosting-models">进程内托管模型</a>）相同的进程中。 “进程内”建议的配置。</li>
<li>在独立于 IIS 工作进程（<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/?view=aspnetcore-2.2&tabs=windows#hosting-models">进程外托管模型</a>）和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/?view=aspnetcore-2.2&tabs=windows#kestrel">Kestrel 服务器</a>的进程中。</li>
</ul>
<h4 id="Kestrel-与-HTTP-sys"><a href="#Kestrel-与-HTTP-sys" class="headerlink" title="Kestrel 与 HTTP.sys"></a>Kestrel 与 HTTP.sys</h4><p>Kestrel 具有以下优势：</p>
<ul>
<li>更好的性能和内存利用率。</li>
<li>跨平台</li>
<li>灵活性，它是独立于操作系统进行开发和修补的。</li>
<li>编程端口和 TLS 配置</li>
<li>扩展性，允许 <a target="_blank" rel="noopener" href="https://github.com/aspnet/AspLabs/blob/main/src/ProxyProtocol/ProxyProtocol.Sample/ProxyProtocol.cs">PPv2</a> 等协议和备用传输。</li>
</ul>
<p>Http.Sys 作为共享内核模式组件运行，具有 kestrel 不具备的以下功能：</p>
<ul>
<li>端口共享</li>
<li>内核模式 Windows 身份验证。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/windowsauth?view=aspnetcore-2.2#kestrel">Kestrel 仅支持用户模式的身份验证</a>。</li>
<li>通过队列传输的快速代理</li>
<li>直接文件传输</li>
<li>响应缓存</li>
</ul>
<h4 id="托管模型"><a href="#托管模型" class="headerlink" title="托管模型"></a>托管模型</h4><p>使用进程内托管，ASP.NET Core 在与其 IIS 工作进程相同的进程中运行。 进程内承载相较进程外承载提供更优的性能，因为请求并不通过环回适配器进行代理，环回适配器是一个网络接口，用于将传出的网络流量返回给同一计算机。IIS 使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/iis/manage/provisioning-and-managing-iis/features-of-the-windows-process-activation-service-was">Windows 进程激活服务 (WAS)</a> 处理进程管理。</p>
<p>通过进程外托管，ASP.NET Core 应用在独立于 IIS 工作进程的进程中运行，而由模块来处理进程管理。 该模块在第一个请求到达时启动 ASP.NET Core 应用的进程，并在应用关闭或崩溃时重新启动该应用。 这基本上与在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/iis/manage/provisioning-and-managing-iis/features-of-the-windows-process-activation-service-was">Windows 进程激活服务 (WAS)</a> 托管的进程内运行的应用中出现的行为相同。 使用单独的进程还可以托管同一个应用池中的多个应用。</p>
<h4 id="Kestrel"><a href="#Kestrel" class="headerlink" title="Kestrel"></a>Kestrel</h4><p>使用 Kestrel：</p>
<ul>
<li><p>本身作为边缘服务器，处理直接来自网络（包括 Internet）的请求。</p>
<p><img src="/2022/07/07/2022-07-07/kestrel-to-internet2.pngview=aspnetcore-2.2" alt="Kestrel 直接与 Internet 通信，不使用反向代理服务器"></p>
</li>
<li><p>与反向代理服务器（如 <a target="_blank" rel="noopener" href="https://www.iis.net/">Internet Information Services (IIS)</a>、<a target="_blank" rel="noopener" href="https://nginx.org/">Nginx</a> 或 <a target="_blank" rel="noopener" href="https://httpd.apache.org/">Apache</a>）结合使用。 反向代理服务器接收来自 Internet 的 HTTP 请求，并将这些请求转发到 Kestrel。</p>
<p><img src="/2022/07/07/2022-07-07/kestrel-to-internet.pngview=aspnetcore-2.2" alt="Kestrel 通过反向代理服务器（如 IIS、Nginx 或 Apache）间接与 Internet 进行通信"></p>
</li>
</ul>
<h4 id="HTTP-sys"><a href="#HTTP-sys" class="headerlink" title="HTTP.sys"></a>HTTP.sys</h4><p>如果 ASP.NET Core 应用在 Windows 上运行，则 HTTP.sys 是 Kestrel 的替代选项。 与 HTTP.sys 相比，建议使用 Kestrel，除非应用需要 Kestrel 未提供的功能。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-2.2">ASP.NET Core 中的 HTTP.sys Web 服务器实现</a>。</p>
<p><img src="2022-07-07/httpsys-to-internet.pngview=aspnetcore-2.2" alt="HTTP.sys 直接与 Internet 进行通信"></p>
<p>对于仅向内部网络公开的应用，HTTP.sys 同样适用。</p>
<p><img src="2022-07-07/httpsys-to-internal.pngview=aspnetcore-2.2" alt="HTTP.sys 直接与内部网络进行通信"></p>
<p>有关 HTTP.sys 配置指南，请参阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-2.2">ASP.NET Core 中的 HTTP.sys Web 服务器实现</a>。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：</p>
<ul>
<li>选择是否将请求传递到管道中的下一个组件。</li>
<li>可在管道中的下一个组件前后执行工作。</li>
</ul>
<p>每个委托均可在下一个委托前后执行操作。 应尽早在管道中调用异常处理委托，这样它们就能捕获在管道的后期阶段发生的异常。</p>
<p>尽可能简单的 ASP.NET Core 应用设置了处理所有请求的单个请求委托。 这种情况不包括实际请求管道。 调用单个匿名函数以响应每个 HTTP 请求。</p>
<pre><code class="c#">public class Startup
&#123;
    public void Configure(IApplicationBuilder app)
    &#123;
        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Hello, World!&quot;);
        &#125;);
    &#125;
&#125;
</code></pre>
<p>用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.useextensions.use">Use</a> 将多个请求委托链接在一起。 <code>next</code> 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路。 通常可在下一个委托前后执行操作，如以下示例所示：</p>
<pre><code class="c#">public class Startup
&#123;
    public void Configure(IApplicationBuilder app)
    &#123;
        app.Use(async (context, next) =&gt;
        &#123;
            // Do work that doesn&#39;t write to the Response.
            await next.Invoke();
            // Do logging or other work that doesn&#39;t write to the Response.
        &#125;);

        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Hello from 2nd delegate.&quot;);
        &#125;);
    &#125;
&#125;
</code></pre>
<h4 id="中间件顺序"><a href="#中间件顺序" class="headerlink" title="中间件顺序"></a>中间件顺序</h4><p>向 <code>Startup.Configure</code> 方法添加中间件组件的顺序定义了针对请求调用这些组件的顺序，以及响应的相反顺序。 此顺序对于安全性、性能和功能至关重要。</p>
<p>下面的 <code>Startup.Configure</code> 方法按照典型的建议顺序增加与安全相关的中间件组件：</p>
<pre><code class="c#">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
&#123;
    if (env.IsDevelopment())
    &#123;
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
    &#125;
    else
    &#123;
        app.UseExceptionHandler(&quot;/Error&quot;);
        app.UseHsts();
    &#125;

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    // app.UseCookiePolicy();

    app.UseRouting();
    // app.UseRequestLocalization();
    // app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();
    // app.UseSession();
    // app.UseResponseCompression();
    // app.UseResponseCaching();

    app.UseEndpoints(endpoints =&gt;
    &#123;
        endpoints.MapRazorPages();
        endpoints.MapControllerRoute(
            name: &quot;default&quot;,
            pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;);
    &#125;);
&#125;
</code></pre>
<h4 id="对中间件管道进行分支"><a href="#对中间件管道进行分支" class="headerlink" title="对中间件管道进行分支"></a>对中间件管道进行分支</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map">Map</a> 扩展用作约定来创建管道分支。 <code>Map</code> 基于给定请求路径的匹配项来创建请求管道分支。 如果请求路径以给定路径开头，则执行分支。</p>
<pre><code class="c#">public class Startup
&#123;
    private static void HandleMapTest1(IApplicationBuilder app)
    &#123;
        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Map Test 1&quot;);
        &#125;);
    &#125;

    private static void HandleMapTest2(IApplicationBuilder app)
    &#123;
        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Map Test 2&quot;);
        &#125;);
    &#125;

    public void Configure(IApplicationBuilder app)
    &#123;
        app.Map(&quot;/map1&quot;, HandleMapTest1);

        app.Map(&quot;/map2&quot;, HandleMapTest2);

        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Hello from non-Map delegate. &lt;p&gt;&quot;);
        &#125;);
    &#125;
&#125;
</code></pre>
<p><img src="/2022/07/07/2022-07-07/image-20220707144453253.png" alt="image-20220707144453253"></p>
<p><code>Map</code> 支持嵌套，例如：</p>
<pre><code class="c#">app.Map(&quot;/level1&quot;, level1App =&gt; &#123;
    level1App.Map(&quot;/level2a&quot;, level2AApp =&gt; &#123;
        // &quot;/level1/level2a&quot; processing
    &#125;);
    level1App.Map(&quot;/level2b&quot;, level2BApp =&gt; &#123;
        // &quot;/level1/level2b&quot; processing
    &#125;);
&#125;);
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.mapwhenextensions.mapwhen">MapWhen</a> 基于给定谓词的结果创建请求管道分支。 <code>Func&lt;HttpContext, bool&gt;</code> 类型的任何谓词均可用于将请求映射到管道的新分支。 在以下示例中，谓词用于检测查询字符串变量 <code>branch</code> 是否存在：</p>
<pre><code class="c#">public class Startup
&#123;
    private static void HandleBranch(IApplicationBuilder app)
    &#123;
        app.Run(async context =&gt;
        &#123;
            var branchVer = context.Request.Query[&quot;branch&quot;];
            await context.Response.WriteAsync($&quot;Branch used = &#123;branchVer&#125;&quot;);
        &#125;);
    &#125;

    public void Configure(IApplicationBuilder app)
    &#123;
        app.MapWhen(context =&gt; context.Request.Query.ContainsKey(&quot;branch&quot;),
                               HandleBranch);

        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Hello from non-Map delegate. &lt;p&gt;&quot;);
        &#125;);
    &#125;
&#125;
</code></pre>
<p>下表使用前面的代码显示来自 <code>http://localhost:1234</code> 的请求和响应：</p>
<table>
<thead>
<tr>
<th align="left">请求</th>
<th align="left">响应</th>
</tr>
</thead>
<tbody><tr>
<td align="left">localhost:1234</td>
<td align="left">Hello from non-Map delegate.</td>
</tr>
<tr>
<td align="left">localhost:1234/?branch=main</td>
<td align="left">Branch used = main</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen">UseWhen</a> 也基于给定谓词的结果创建请求管道分支。 与 <code>MapWhen</code> 不同的是，如果这个分支不发生短路或包含终端中间件，则会重新加入主管道：</p>
<pre><code class="c#">public class Startup
&#123;
    private void HandleBranchAndRejoin(IApplicationBuilder app)
    &#123;
        app.Use(async (context, next) =&gt;
        &#123;
            var branchVer = context.Request.Query[&quot;branch&quot;];
            await context.Response.WriteAsync($&quot;Branch used = &#123;branchVer&#125;&quot;);

            // Do work that doesn&#39;t write to the Response.
            await next();
            // Do other work that doesn&#39;t write to the Response.
        &#125;);
    &#125;

    public void Configure(IApplicationBuilder app, ILogger&lt;Startup&gt; logger)
    &#123;
        app.UseWhen(context =&gt; context.Request.Query.ContainsKey(&quot;branch&quot;),
                               appBuilder =&gt; HandleBranchAndRejoin(appBuilder));

        app.Run(async context =&gt;
        &#123;
            await context.Response.WriteAsync(&quot;Hello World!&quot;);
        &#125;);
    &#125;
&#125;
</code></pre>
<p>在前面的示例中，为所有请求写入“Hello from main pipeline.”响应。 如果请求中包含查询字符串变量 <code>branch</code>，则在重新加入主管道之前会记录其值。</p>
<p><img src="/2022/07/07/2022-07-07/image-20220707145341044.png" alt="image-20220707145341044"></p>
<h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><h4 id="设置泛型主机"><a href="#设置泛型主机" class="headerlink" title="设置泛型主机"></a>设置泛型主机</h4><p>主机通常由 <code>Program</code> 类中的代码配置、生成和运行。 <code>Main</code> 方法：</p>
<ul>
<li>调用 <code>CreateHostBuilder</code> 方法以创建和配置生成器对象。</li>
<li>对生成器对象调用 <code>Build</code> 和 <code>Run</code> 方法。</li>
</ul>
<pre><code class="c#">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<h4 id="设置Web主机"><a href="#设置Web主机" class="headerlink" title="设置Web主机"></a>设置Web主机</h4><p>创建使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.hosting.iwebhostbuilder">IWebHostBuilder</a> 实例的主机。 通常在应用的入口点来执行 <code>Main</code> 方法。</p>
<p>在项目模板中，<code>Main</code> 位于 <code>Program.cs</code> 中。 典型应用调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.aspnetcore.webhost.createdefaultbuilder">CreateDefaultBuilder</a> 来开始创建主机：</p>
<pre><code class="c#">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateWebHostBuilder(args).Build().Run();
    &#125;

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&lt;Startup&gt;();
&#125;
</code></pre>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>ASP.NET Core 中的配置是使用一个或多个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#cp">配置提供程序</a>执行的。 配置提供程序使用各种配置源从键值对读取配置数据：</p>
<ul>
<li>设置文件，例如 <code>appsettings.json</code></li>
<li>环境变量</li>
<li>Azure Key Vault</li>
<li>Azure 应用程序配置</li>
<li>命令行参数</li>
<li>已安装或已创建的自定义提供程序</li>
<li>目录文件</li>
<li>内存中的 .NET 对象</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.hosting.host.createdefaultbuilder">CreateDefaultBuilder</a> 按照以下顺序为应用提供默认配置：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.chainedconfigurationsource">ChainedConfigurationProvider</a>：添加现有的 <code>IConfiguration</code> 作为源。 在默认配置示例中，添加<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#hvac">主机</a>配置，并将它设置为应用配置的第一个源。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#file-configuration-provider">JSON 配置提供程序</a>通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#appsettingsjson">appsettings.json</a> 提供。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#file-configuration-provider">JSON 配置提供程序</a>通过 <code>appsettings.&#123;Environment&#125;.json</code> 提供。 例如，<code>appsettings.Production.json</code> 和 <code>appsettings.Development.json</code>。</li>
<li>应用在 <code>Development</code> 环境中运行时的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets?view=aspnetcore-3.1">应用机密</a>。</li>
<li>使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a>通过环境变量提供。</li>
<li>使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>通过命令行参数提供。</li>
</ol>
<p>后来添加的配置提供程序会替代之前的密钥设置。 例如，如果 <code>appsettings.json</code> 和环境中都设置了 <code>MyKey</code>，则使用环境值。 通过默认配置提供程序，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>将替代其他所有提供程序。</p>
<h4 id="appsettings-json-1"><a href="#appsettings-json-1" class="headerlink" title="appsettings.json"></a>appsettings.json</h4><p>请考虑以下 <code>appsettings.json</code> 文件：</p>
<pre><code class="json">&#123;
  &quot;Position&quot;: &#123;
    &quot;Title&quot;: &quot;Editor&quot;,
    &quot;Name&quot;: &quot;Joe Smith&quot;
  &#125;,
  &quot;MyKey&quot;:  &quot;My appsettings.json Value&quot;,
  &quot;Logging&quot;: &#123;
    &quot;LogLevel&quot;: &#123;
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    &#125;
  &#125;,
  &quot;AllowedHosts&quot;: &quot;*&quot;
&#125;
</code></pre>
<p>读取</p>
<pre><code class="c#">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="使用选项模式绑定分层配置数据"><a href="#使用选项模式绑定分层配置数据" class="headerlink" title="使用选项模式绑定分层配置数据"></a>使用选项模式绑定分层配置数据</h4><p>读取相关配置值的首选方法是使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1">选项模式</a>。 例如，若要读取以下配置值，请执行以下操作：</p>
<pre><code class="json">&quot;Position&quot;: &#123;
    &quot;Title&quot;: &quot;Editor&quot;,
    &quot;Name&quot;: &quot;Joe Smith&quot;
  &#125;
</code></pre>
<p>创建以下 <code>PositionOptions</code> 类：</p>
<pre><code class="c#">public class PositionOptions
&#123;
    public const string Position = &quot;Position&quot;;

    public string Title &#123; get; set; &#125;
    public string Name &#123; get; set; &#125;
&#125;
</code></pre>
<p>选项类：</p>
<ul>
<li>必须是包含公共无参数构造函数的非抽象类。</li>
<li>类型的所有公共读写属性都已绑定。</li>
<li>字段不是绑定的。 在上面的代码中，<code>Position</code> 未绑定。 由于使用了 <code>Position</code> 属性，因此在将类绑定到配置提供程序时，不需要在应用中对字符串 <code>&quot;Position&quot;</code> 进行硬编码。</li>
</ul>
<p>显示 <code>Position</code> 配置数据。</p>
<pre><code class="c#">public class Test22Model : PageModel
&#123;
    private readonly IConfiguration Configuration;

    public Test22Model(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var positionOptions = new PositionOptions();
        Configuration.GetSection(PositionOptions.Position).Bind(positionOptions);

        return Content($&quot;Title: &#123;positionOptions.Title&#125; \n&quot; +
                       $&quot;Name: &#123;positionOptions.Name&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationbinder.get"><code>ConfigurationBinder.Get</code></a> 绑定并返回指定的类型。 使用 <code>ConfigurationBinder.Get&lt;T&gt;</code> 可能比使用 <code>ConfigurationBinder.Bind</code> 更方便。 下面的代码演示如何将 <code>ConfigurationBinder.Get&lt;T&gt;</code> 与 <code>PositionOptions</code> 类配合使用：</p>
<pre><code class="c#">public class Test21Model : PageModel
&#123;
    private readonly IConfiguration Configuration;
    public PositionOptions positionOptions &#123; get; private set; &#125;

    public Test21Model(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;            
        positionOptions = Configuration.GetSection(PositionOptions.Position)
                                                     .Get&lt;PositionOptions&gt;();

        return Content($&quot;Title: &#123;positionOptions.Title&#125; \n&quot; +
                       $&quot;Name: &#123;positionOptions.Name&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>在上面的代码中，默认读取在应用启动后对 JSON 配置文件所做的更改。</p>
<p>使用选项模式时的另一种方法是绑定 <code>Position</code> 部分，并将其添加到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">依赖关系注入服务容器</a>中。 在以下代码中，<code>PositionOptions</code> 已通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.dependencyinjection.optionsconfigurationservicecollectionextensions.configure">Configure</a> 被添加到了服务容器并已绑定到了配置：</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    services.Configure&lt;PositionOptions&gt;(Configuration.GetSection(
                                        PositionOptions.Position));
    services.AddRazorPages();
&#125;
</code></pre>
<p>通过使用前面的代码，以下代码将读取位置选项：</p>
<pre><code class="c#">public class Test2Model : PageModel
&#123;
    private readonly PositionOptions _options;

    public Test2Model(IOptions&lt;PositionOptions&gt; options)
    &#123;
        _options = options.Value;
    &#125;

    public ContentResult OnGet()
    &#123;
        return Content($&quot;Title: &#123;_options.Title&#125; \n&quot; +
                       $&quot;Name: &#123;_options.Name&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>在上面的代码中，不会读取在应用启动后对 JSON 配置文件所做的更改。 若要读取在应用启动后的更改，请使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1#ios">IOptionsSnapshot</a>。//TO==选项==</p>
<h4 id="合并服务集合"><a href="#合并服务集合" class="headerlink" title="合并服务集合"></a>合并服务集合</h4><p>请考虑下面的 <code>ConfigureServices</code> 方法，该方法可注册服务并配置选项：</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    services.Configure&lt;PositionOptions&gt;(
        Configuration.GetSection(PositionOptions.Position));
    services.Configure&lt;ColorOptions&gt;(
        Configuration.GetSection(ColorOptions.Color));

    services.AddScoped&lt;IMyDependency, MyDependency&gt;();
    services.AddScoped&lt;IMyDependency2, MyDependency2&gt;();

    services.AddRazorPages();
&#125;
</code></pre>
<p>可以将相关的注册组移动到扩展方法以注册服务。 例如，配置服务会被添加到以下类中：</p>
<pre><code class="c#">using ConfigSample.Options;
using Microsoft.Extensions.Configuration;

namespace Microsoft.Extensions.DependencyInjection
&#123;
    public static class MyConfigServiceCollectionExtensions
    &#123;
        public static IServiceCollection AddConfig(
             this IServiceCollection services, IConfiguration config)
        &#123;
            services.Configure&lt;PositionOptions&gt;(
                config.GetSection(PositionOptions.Position));
            services.Configure&lt;ColorOptions&gt;(
                config.GetSection(ColorOptions.Color));

            return services;
        &#125;
    &#125;
    //TODO:Test==
    public static IServiceCollection AddMyDependencyGroup(
             this IServiceCollection services)
        &#123;
            services.AddScoped&lt;IMyDependency, MyDependency&gt;();
            services.AddScoped&lt;IMyDependency2, MyDependency2&gt;();

            return services;
        &#125;
&#125;
</code></pre>
<p>剩余的服务会在类似的类中注册。 下面的 <code>ConfigureServices</code> 方法使用新扩展方法来注册服务：</p>
<pre><code class="c#">public void ConfigureServices(IServiceCollection services)
&#123;
    services.AddConfig(Configuration)
            .AddMyDependencyGroup();

    services.AddRazorPages();
&#125;
</code></pre>
<h4 id="安全性和用户机密"><a href="#安全性和用户机密" class="headerlink" title="安全性和用户机密"></a>安全性和用户机密</h4><p>配置数据指南：</p>
<ul>
<li>请勿在配置提供程序代码或纯文本配置文件中存储密码或其他敏感数据。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets?view=aspnetcore-3.1">机密管理器</a>工具可用于存储开发环境中的机密。</li>
<li>不要在开发或测试环境中使用生产机密。</li>
<li>请在项目外部指定机密，避免将其意外提交到源代码存储库。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认</a>情况下，将在 JSON 配置源后注册用户机密配置源。 因此，用户机密密钥优先于 <code>appsettings.json</code> 和 <code>appsettings.&#123;Environment&#125;.json</code> 中的密钥。</p>
<p>存储数据库连接字符串</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets?view=aspnetcore-3.1&amp;tabs=windows#string-replacement-with-secrets-1">https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets?view=aspnetcore-3.1&amp;tabs=windows#string-replacement-with-secrets-1</a></p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>所有平台上的环境变量分层键都不支持 <code>:</code> 分隔符。 <code>__</code>（双下划线）：</p>
<ul>
<li>受所有平台支持。 例如，<a target="_blank" rel="noopener" href="https://linuxhint.com/bash-environment-variables/">Bash</a> 不支持 <code>:</code> 分隔符，但支持 <code>__</code>。</li>
<li>自动替换为 <code>:</code></li>
</ul>
<p>以下 <code>set</code> 命令：</p>
<ul>
<li>在 Windows 上设置<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#appsettingsjson">上述示例</a>的环境键和值。</li>
<li>在使用<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>时测试设置。 <code>dotnet run</code> 命令必须在项目目录中运行。</li>
</ul>
<pre><code class="c#">set MyKey=&quot;My key from Environment&quot;
set Position__Title=Environment_Editor
set Position__Name=Environment_Rick
dotnet run
</code></pre>
<p>前面的环境设置：</p>
<ul>
<li>仅在进程中设置，这些进程是从设置进程的命令窗口启动的。</li>
<li>不会由通过 Visual Studio 启动的浏览器读取。</li>
</ul>
<p>以下 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/windows-server/administration/windows-commands/setx">setx</a> 命令可用于在 Windows 上设置环境键和值。 与 <code>set</code> 不同，<code>setx</code> 设置是持久的。 <code>/M</code> 在系统环境中设置变量。 如果未使用 <code>/M</code> 开关，则会设置用户环境变量。</p>
<pre><code class="c#">setx MyKey &quot;My key from setx Environment&quot; /M
setx Position__Title Environment_Editor /M
setx Position__Name Environment_Rick /M
</code></pre>
<p><img src="/2022/07/07/2022-07-07/image-20220707155750681.png" alt="image-20220707155750681"></p>
<p><img src="/2022/07/07/2022-07-07/image-20220707155932350.png" alt="image-20220707155932350"></p>
<p>使用字符串调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.environmentvariablesextensions.addenvironmentvariables">AddEnvironmentVariables</a> 以指定环境变量的前缀：</p>
<pre><code class="c#">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddEnvironmentVariables(prefix: &quot;MyCustomPrefix_&quot;);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>在上述代码中：</p>
<ul>
<li><code>config.AddEnvironmentVariables(prefix: &quot;MyCustomPrefix_&quot;)</code> 被添加到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置提供程序</a>之后。 有关对配置提供程序进行排序的示例，请参阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#jcp">JSON 配置提供程序</a>。</li>
<li>使用 <code>MyCustomPrefix_</code> 前缀设置的环境变量将替代<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置提供程序</a>。 这包括没有前缀的环境变量。</li>
</ul>
<p>前缀会在读取配置键值对时被去除。</p>
<p>以下命令对自定义前缀进行测试：</p>
<pre><code class="c#">set MyCustomPrefix_MyKey=&quot;My key with MyCustomPrefix_ Environment&quot;
set MyCustomPrefix_Position__Title=Editor_with_customPrefix
set MyCustomPrefix_Position__Name=Environment_Rick_cp
dotnet run
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置</a>会加载前缀为 <code>DOTNET_</code> 和 <code>ASPNETCORE_</code> 的环境变量和命令行参数。 <code>DOTNET_</code> 和 <code>ASPNETCORE_</code> 前缀会由 ASP.NET Core 用于<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1#host-configuration">主机和应用配置</a>，但不用于用户配置。 有关主机和应用配置的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1">.NET 通用主机</a>。</p>
<h4 id="环境变量的命名"><a href="#环境变量的命名" class="headerlink" title="环境变量的命名"></a>环境变量的命名</h4><p>环境变量名称反映了 <code>appsettings.json</code> 文件的结构。 层次结构中的每个元素由双下划线字符（更可取）或冒号分隔。 当元素结构包含数组时，应将数组索引视为此路径中的附加元素名称。 请考虑以下 <code>appsettings.json</code> 文件及其表示为环境变量的等效值。</p>
<p><em><code>appsettings.json</code></em></p>
<pre><code class="json">&#123;
    &quot;SmtpServer&quot;: &quot;smtp.example.com&quot;,
    &quot;Logging&quot;: [
        &#123;
            &quot;Name&quot;: &quot;ToEmail&quot;,
            &quot;Level&quot;: &quot;Critical&quot;,
            &quot;Args&quot;: &#123;
                &quot;FromAddress&quot;: &quot;MySystem@example.com&quot;,
                &quot;ToAddress&quot;: &quot;SRE@example.com&quot;
            &#125;
        &#125;,
        &#123;
            &quot;Name&quot;: &quot;ToConsole&quot;,
            &quot;Level&quot;: &quot;Information&quot;
        &#125;
    ]
&#125;
</code></pre>
<p>环境变量</p>
<pre><code class="powershell">setx SmtpServer smtp.example.com
setx Logging__0__Name ToEmail
setx Logging__0__Level Critical
setx Logging__0__Args__FromAddress MySystem@example.com
setx Logging__0__Args__ToAddress SRE@example.com
setx Logging__1__Name ToConsole
setx Logging__1__Level Information
</code></pre>
<h4 id="在生成的-launchSettings-json-中设置的环境变量"><a href="#在生成的-launchSettings-json-中设置的环境变量" class="headerlink" title="在生成的 launchSettings.json 中设置的环境变量"></a>在生成的 launchSettings.json 中设置的环境变量</h4><p>在 <code>launchSettings.json</code> 中设置的环境变量将替代在系统环境中设置的变量。 例如，ASP.NET Core Web 模板会生成一个 <code>launchSettings.json</code> 文件，该文件将终结点配置设置为：</p>
<pre><code class="json">&quot;applicationUrl&quot;: &quot;https://localhost:5001;http://localhost:5000&quot;
</code></pre>
<p>配置 <code>applicationUrl</code> 将设置 <code>ASPNETCORE_URLS</code> 环境变量并重写环境中设置的值。</p>
<h4 id="在-Linux-上转义环境变量"><a href="#在-Linux-上转义环境变量" class="headerlink" title="在 Linux 上转义环境变量"></a>在 Linux 上转义环境变量</h4><p>在 Linux 上，必须转义 URL 环境变量的值，使 <code>systemd</code> 可以对其进行分析。 使用 Linux 工具 <code>systemd-escape</code> 生成 <code>http:--localhost:5001</code></p>
<pre><code class="cmd">groot@terminus:~$ systemd-escape http://localhost:5001
http:--localhost:5001
</code></pre>
<h4 id="显示环境变量"><a href="#显示环境变量" class="headerlink" title="显示环境变量"></a>显示环境变量</h4><p>下面的代码显示了应用程序启动时的环境变量和值，这对调试环境设置很有帮助：</p>
<pre><code class="c#">public static void Main(string[] args)
&#123;
    var host = CreateHostBuilder(args).Build();

    var config = host.Services.GetRequiredService&lt;IConfiguration&gt;();

    foreach (var c in config.AsEnumerable())
    &#123;
        Console.WriteLine(c.Key + &quot; = &quot; + c.Value);
    &#125;
    host.Run();
&#125;
</code></pre>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认</a>配置，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.commandline.commandlineconfigurationprovider">CommandLineConfigurationProvider</a> 会从以下配置源后的命令行参数键值对中加载配置：</p>
<ul>
<li><code>appsettings.json</code> 和 <code>appsettings.&#123;Environment&#125;.json</code> 文件。</li>
<li>开发环境中的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets?view=aspnetcore-3.1">应用机密</a>。</li>
<li>环境变量。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认情况下</a>，在命令行上设置的配置值会替代通过所有其他配置提供程序设置的配置值。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>以下命令使用 <code>=</code> 设置键和值：</p>
<pre><code class="dotnetcli">dotnet run MyKey=&quot;Using =&quot; Position:Title=Cmd Position:Name=Cmd_Rick
</code></pre>
<p>以下命令使用 <code>/</code> 设置键和值：</p>
<pre><code class="dotnetcli">dotnet run /MyKey &quot;Using /&quot; /Position:Title=Cmd /Position:Name=Cmd_Rick
</code></pre>
<p>以下命令使用 <code>--</code> 设置键和值：</p>
<pre><code class="dotnetcli">dotnet run --MyKey &quot;Using --&quot; --Position:Title=Cmd --Position:Name=Cmd_Rick
</code></pre>
<p>键值：</p>
<ul>
<li>必须后跟 <code>=</code>，或者当值后跟一个空格时，键必须具有一个 <code>--</code> 或 <code>/</code> 的前缀。</li>
<li>如果使用 <code>=</code>，则不是必需的。 例如 <code>MySetting=</code>。</li>
</ul>
<p>在同一命令中，请勿将使用 <code>=</code> 的命令行参数键值对与使用空格的键值对混合使用。</p>
<h4 id="交换映射"><a href="#交换映射" class="headerlink" title="交换映射"></a>交换映射</h4><p>交换映射支持键名替换逻辑。 提供针对 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline">AddCommandLine</a> 方法的交换替换字典。</p>
<p>当使用交换映射字典时，会检查字典中是否有与命令行参数提供的键匹配的键。 如果在字典中找到了命令行键，则会传回字典值将键值对设置为应用的配置。 对任何具有单划线 (<code>-</code>) 前缀的命令行键而言，交换映射都是必需的。</p>
<p>交换映射字典键规则：</p>
<ul>
<li>交换必须以 <code>-</code> 或 <code>--</code> 开头。</li>
<li>交换映射字典不得包含重复键。</li>
</ul>
<p>若要使用交换映射字典，请将它传递到对 <code>AddCommandLine</code> 的调用中：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args)
    &#123;
        var switchMappings = new Dictionary&lt;string, string&gt;()
         &#123;
             &#123; &quot;-k1&quot;, &quot;key1&quot; &#125;,
             &#123; &quot;-k2&quot;, &quot;key2&quot; &#125;,
             &#123; &quot;--alt3&quot;, &quot;key3&quot; &#125;,
             &#123; &quot;--alt4&quot;, &quot;key4&quot; &#125;,
             &#123; &quot;--alt5&quot;, &quot;key5&quot; &#125;,
             &#123; &quot;--alt6&quot;, &quot;key6&quot; &#125;,
         &#125;;

        return Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddCommandLine(args, switchMappings);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
    &#125;
&#125;
</code></pre>
<p>下面的代码显示了替换后的键的键值：</p>
<pre><code class="csharp">public class Test3Model : PageModel
&#123;
    private readonly IConfiguration Config;

    public Test3Model(IConfiguration configuration)
    &#123;
        Config = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        return Content(
                $&quot;Key1: &#39;&#123;Config[&quot;Key1&quot;]&#125;&#39;\n&quot; +
                $&quot;Key2: &#39;&#123;Config[&quot;Key2&quot;]&#125;&#39;\n&quot; +
                $&quot;Key3: &#39;&#123;Config[&quot;Key3&quot;]&#125;&#39;\n&quot; +
                $&quot;Key4: &#39;&#123;Config[&quot;Key4&quot;]&#125;&#39;\n&quot; +
                $&quot;Key5: &#39;&#123;Config[&quot;Key5&quot;]&#125;&#39;\n&quot; +
                $&quot;Key6: &#39;&#123;Config[&quot;Key6&quot;]&#125;&#39;&quot;);
    &#125;
&#125;
</code></pre>
<p>以下命令可用于测试键替换：</p>
<pre><code class="dotnetcli">dotnet run -k1 value1 -k2 value2 --alt3=value2 /alt4=value3 --alt5 value5 /alt6 value6
</code></pre>
<p>对于使用交换映射的应用，调用 <code>CreateDefaultBuilder</code> 不应传递参数。 <code>CreateDefaultBuilder</code> 方法的 <code>AddCommandLine</code> 调用不包括映射的交换，并且无法将交换映射字典传递给 <code>CreateDefaultBuilder</code>。 解决方案不是将参数传递给 <code>CreateDefaultBuilder</code>，而是允许 <code>ConfigurationBuilder</code> 方法的 <code>AddCommandLine</code> 方法处理参数和交换映射字典。</p>
<h4 id="在-Visual-Studio-中设置环境和命令行参数"><a href="#在-Visual-Studio-中设置环境和命令行参数" class="headerlink" title="在 Visual Studio 中设置环境和命令行参数"></a>在 Visual Studio 中设置环境和命令行参数</h4><p><img src="/2022/07/07/2022-07-07/image-20220707162507544.png" alt="image-20220707162507544"></p>
<h4 id="分层配置数据"><a href="#分层配置数据" class="headerlink" title="分层配置数据"></a>分层配置数据</h4><p>配置 API 在配置键中使用分隔符来展平分层数据，以此来读取分层配置数据。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>包含以下 <code>appsettings.json</code> 文件：</p>
<pre><code class="json">&#123;
  &quot;Position&quot;: &#123;
    &quot;Title&quot;: &quot;Editor&quot;,
    &quot;Name&quot;: &quot;Joe Smith&quot;
  &#125;,
  &quot;MyKey&quot;:  &quot;My appsettings.json Value&quot;,
  &quot;Logging&quot;: &#123;
    &quot;LogLevel&quot;: &#123;
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    &#125;
  &#125;,
  &quot;AllowedHosts&quot;: &quot;*&quot;
&#125;
</code></pre>
<p>以下来自<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>的代码显示了一些配置设置：</p>
<pre><code class="csharp">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>读取分层配置数据的首选方法是使用选项模式。 有关详细信息，请参阅本文档中的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#optpat">绑定分层配置数据</a>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationsection.getsection">GetSection</a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren">GetChildren</a> 方法可用于隔离各个节和配置数据中某节的子节。 稍后将在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#getsection">GetSection、GetChildren 和 Exists</a> 中介绍这些方法。</p>
<h4 id="配置键和值"><a href="#配置键和值" class="headerlink" title="配置键和值"></a>配置键和值</h4><p>配置键：</p>
<ul>
<li>不区分大小写。 例如，<code>ConnectionString</code> 和 <code>connectionstring</code> 被视为等效键。</li>
<li>如果在多个配置提供程序中设置了某一键和值，则会使用最后添加的提供程序中的值。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置</a>。</li>
<li>分层键<ul>
<li>在配置 API 中，冒号分隔符 (<code>:</code>) 适用于所有平台。</li>
<li>在环境变量中，冒号分隔符可能无法适用于所有平台。 所有平台均支持采用双下划线 <code>__</code>，并且它会自动转换为冒号 <code>:</code>。</li>
<li>在 Azure Key Vault 中，分层键使用 <code>--</code> 作为分隔符。 当机密加载到应用的配置中时，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/key-vault-configuration?view=aspnetcore-3.1">Azure Key Vault 配置提供程序</a> 会自动将 <code>--</code> 替换为 <code>:</code>。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationbinder">ConfigurationBinder</a> 支持使用配置键中的数组索引将数组绑定到对象。 数组绑定将在<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#boa">将数组绑定到类</a>部分中进行介绍。</li>
</ul>
<p>配置值：</p>
<ul>
<li>为字符串。</li>
<li>NULL 值不能存储在配置中或绑定到对象。</li>
</ul>
<h4 id="连接字符串前缀"><a href="#连接字符串前缀" class="headerlink" title="连接字符串前缀"></a>连接字符串前缀</h4><p>==TODO==</p>
<p>对于四个连接字符串环境变量，配置 API 具有特殊的处理规则。 这些连接字符串涉及了为应用环境配置 Azure 连接字符串。 使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置</a>或没有向 <code>AddEnvironmentVariables</code> 应用前缀时，具有表中所示前缀的环境变量将加载到应用中。</p>
<table>
<thead>
<tr>
<th align="left">连接字符串前缀</th>
<th align="left">提供程序</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CUSTOMCONNSTR_</code></td>
<td align="left">自定义提供程序</td>
</tr>
<tr>
<td align="left"><code>MYSQLCONNSTR_</code></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.mysql.com/">MySQL</a></td>
</tr>
<tr>
<td align="left"><code>SQLAZURECONNSTR_</code></td>
<td align="left"><a target="_blank" rel="noopener" href="https://azure.microsoft.com/services/sql-database/">Azure SQL 数据库</a></td>
</tr>
<tr>
<td align="left"><code>SQLCONNSTR_</code></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.microsoft.com/sql-server/">SQL Server</a></td>
</tr>
</tbody></table>
<p>当发现环境变量并使用表中所示的四个前缀中的任何一个加载到配置中时：</p>
<ul>
<li>通过删除环境变量前缀并添加配置键节 (<code>ConnectionStrings</code>) 来创建配置键。</li>
<li>创建一个新的配置键值对，表示数据库连接提供程序（<code>CUSTOMCONNSTR_</code> 除外，它没有声明的提供程序）。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">环境变量键</th>
<th align="left">转换的配置键</th>
<th align="left">提供程序配置条目</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CUSTOMCONNSTR_&#123;KEY&#125;</code></td>
<td align="left"><code>ConnectionStrings:&#123;KEY&#125;</code></td>
<td align="left">配置条目未创建。</td>
</tr>
<tr>
<td align="left"><code>MYSQLCONNSTR_&#123;KEY&#125;</code></td>
<td align="left"><code>ConnectionStrings:&#123;KEY&#125;</code></td>
<td align="left">键：<code>ConnectionStrings:&#123;KEY&#125;_ProviderName</code>： 值：<code>MySql.Data.MySqlClient</code></td>
</tr>
<tr>
<td align="left"><code>SQLAZURECONNSTR_&#123;KEY&#125;</code></td>
<td align="left"><code>ConnectionStrings:&#123;KEY&#125;</code></td>
<td align="left">键：<code>ConnectionStrings:&#123;KEY&#125;_ProviderName</code>： 值：<code>System.Data.SqlClient</code></td>
</tr>
<tr>
<td align="left"><code>SQLCONNSTR_&#123;KEY&#125;</code></td>
<td align="left"><code>ConnectionStrings:&#123;KEY&#125;</code></td>
<td align="left">键：<code>ConnectionStrings:&#123;KEY&#125;_ProviderName</code>： 值：<code>System.Data.SqlClient</code></td>
</tr>
</tbody></table>
<h4 id="INI-配置提供程序"><a href="#INI-配置提供程序" class="headerlink" title="INI 配置提供程序"></a>INI 配置提供程序</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.ini.iniconfigurationprovider">IniConfigurationProvider</a> 在运行时从 INI 文件键值对加载配置。</p>
<p>以下代码会清除所有配置提供程序并添加多个配置提供程序：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.Sources.Clear();

                var env = hostingContext.HostingEnvironment;

                config.AddIniFile(&quot;MyIniConfig.ini&quot;, optional: true, reloadOnChange: true)
                      .AddIniFile($&quot;MyIniConfig.&#123;env.EnvironmentName&#125;.ini&quot;,
                                     optional: true, reloadOnChange: true);

                config.AddEnvironmentVariables();

                if (args != null)
                &#123;
                    config.AddCommandLine(args);
                &#125;
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>在前面的代码中，<code>MyIniConfig.ini</code> 和 <code>MyIniConfig.&#123;Environment&#125;.ini</code> 文件中的设置会被以下提供程序中的设置替代：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>包含以下 <code>MyIniConfig.ini</code> 文件：</p>
<pre><code class="ini">MyKey=&quot;MyIniConfig.ini Value&quot;

[Position]
Title=&quot;My INI Config title&quot;
Name=&quot;My INI Config name&quot;

[Logging:LogLevel]
Default=Information
Microsoft=Warning
</code></pre>
<p>以下来自<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>的代码显示了上述的一些配置设置：</p>
<pre><code class="csharp">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="JSON-配置提供程序"><a href="#JSON-配置提供程序" class="headerlink" title="JSON 配置提供程序"></a>JSON 配置提供程序</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.json.jsonconfigurationprovider">JsonConfigurationProvider</a> 从 JSON 文件键值对加载配置。</p>
<p>重载可以指定：</p>
<ul>
<li>文件是否可选。</li>
<li>如果文件更改，是否重载配置。</li>
</ul>
<p>考虑下列代码：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddJsonFile(&quot;MyConfig.json&quot;, 
                    optional: true, 
                    reloadOnChange: true);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>前面的代码：</p>
<ul>
<li>通过以下选项将 JSON 配置提供程序配置为加载<code>MyConfig.json</code>文件：<ul>
<li><code>optional: true</code>：文件是可选的。</li>
<li><code>reloadOnChange: true</code>：保存更改后会重载文件。</li>
</ul>
</li>
<li>读取 <code>MyConfig.json</code> 文件之前的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置提供程序</a>。 <code>MyConfig.json</code> 文件中的设置会替代默认配置提供程序中的设置，包括<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a>和<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>。</li>
</ul>
<p>通常，你不会希望自定义 JSON 文件替代在<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a>和<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>中设置的值。</p>
<p>以下代码会清除所有配置提供程序并添加多个配置提供程序：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.Sources.Clear();

                var env = hostingContext.HostingEnvironment;

                config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile($&quot;appsettings.&#123;env.EnvironmentName&#125;.json&quot;, 
                                     optional: true, reloadOnChange: true);

                config.AddJsonFile(&quot;MyConfig.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile($&quot;MyConfig.&#123;env.EnvironmentName&#125;.json&quot;,
                                     optional: true, reloadOnChange: true);

                config.AddEnvironmentVariables();

                if (args != null)
                &#123;
                    config.AddCommandLine(args);
                &#125;
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>在前面的代码中，<code>MyConfig.json</code> 和 MyConfig.<code>Environment</code>.json 文件中的设置：</p>
<ul>
<li>会替代 <code>appsettings.json</code> 和 <code>appsettings.&#123;Environment&#125;.json</code> 文件中的设置。</li>
<li>会被<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a>和<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>中的设置所替代。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>包含以下 <code>MyConfig.json</code> 文件：</p>
<pre><code class="json">&#123;
  &quot;Position&quot;: &#123;
    &quot;Title&quot;: &quot;My Config title&quot;,
    &quot;Name&quot;: &quot;My Config Smith&quot;
  &#125;,
  &quot;MyKey&quot;:  &quot;MyConfig.json Value&quot;,
  &quot;Logging&quot;: &#123;
    &quot;LogLevel&quot;: &#123;
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    &#125;
  &#125;,
  &quot;AllowedHosts&quot;: &quot;*&quot;
&#125;
</code></pre>
<p>以下来自<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>的代码显示了上述的一些配置设置：</p>
<pre><code class="csharp">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="XML-配置提供程序"><a href="#XML-配置提供程序" class="headerlink" title="XML 配置提供程序"></a>XML 配置提供程序</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.xml.xmlconfigurationprovider">XmlConfigurationProvider</a> 在运行时从 XML 文件键值对加载配置。</p>
<p>以下代码会清除所有配置提供程序并添加多个配置提供程序：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.Sources.Clear();

                var env = hostingContext.HostingEnvironment;

                config.AddXmlFile(&quot;MyXMLFile.xml&quot;, optional: true, reloadOnChange: true)
                      .AddXmlFile($&quot;MyXMLFile.&#123;env.EnvironmentName&#125;.xml&quot;,
                                     optional: true, reloadOnChange: true);

                config.AddEnvironmentVariables();

                if (args != null)
                &#123;
                    config.AddCommandLine(args);
                &#125;
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>在前面的代码中，<code>MyXMLFile.xml</code> 和 <code>MyXMLFile.&#123;Environment&#125;.xml</code> 文件中的设置会被以下提供程序中的设置替代：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#evcp">环境变量配置提供程序</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#clcp">命令行配置提供程序</a>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>包含以下 <code>MyXMLFile.xml</code> 文件：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;configuration&gt;
  &lt;MyKey&gt;MyXMLFile Value&lt;/MyKey&gt;
  &lt;Position&gt;
    &lt;Title&gt;Title from  MyXMLFile&lt;/Title&gt;
    &lt;Name&gt;Name from MyXMLFile&lt;/Name&gt;
  &lt;/Position&gt;
  &lt;Logging&gt;
    &lt;LogLevel&gt;
      &lt;Default&gt;Information&lt;/Default&gt;
      &lt;Microsoft&gt;Warning&lt;/Microsoft&gt;
    &lt;/LogLevel&gt;
  &lt;/Logging&gt;
&lt;/configuration&gt;
</code></pre>
<p>以下来自<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>的代码显示了上述的一些配置设置：</p>
<pre><code class="csharp">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>如果使用 <code>name</code> 属性来区分元素，则使用相同元素名称的重复元素可以正常工作：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
  &lt;section name=&quot;section0&quot;&gt;
    &lt;key name=&quot;key0&quot;&gt;value 00&lt;/key&gt;
    &lt;key name=&quot;key1&quot;&gt;value 01&lt;/key&gt;
  &lt;/section&gt;
  &lt;section name=&quot;section1&quot;&gt;
    &lt;key name=&quot;key0&quot;&gt;value 10&lt;/key&gt;
    &lt;key name=&quot;key1&quot;&gt;value 11&lt;/key&gt;
  &lt;/section&gt;
&lt;/configuration&gt;
</code></pre>
<p>以下代码会读取前面的配置文件并显示键和值：</p>
<pre><code class="csharp">public class IndexModel : PageModel
&#123;
    private readonly IConfiguration Configuration;

    public IndexModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var key00 = &quot;section:section0:key:key0&quot;;
        var key01 = &quot;section:section0:key:key1&quot;;
        var key10 = &quot;section:section1:key:key0&quot;;
        var key11 = &quot;section:section1:key:key1&quot;;

        var val00 = Configuration[key00];
        var val01 = Configuration[key01];
        var val10 = Configuration[key10];
        var val11 = Configuration[key11];

        return Content($&quot;&#123;key00&#125; value: &#123;val00&#125; \n&quot; +
                       $&quot;&#123;key01&#125; value: &#123;val01&#125; \n&quot; +
                       $&quot;&#123;key10&#125; value: &#123;val10&#125; \n&quot; +
                       $&quot;&#123;key10&#125; value: &#123;val11&#125; \n&quot;
                       );
    &#125;
&#125;
</code></pre>
<p>属性可用于提供值：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
  &lt;key attribute=&quot;value&quot; /&gt;
  &lt;section&gt;
    &lt;key attribute=&quot;value&quot; /&gt;
  &lt;/section&gt;
&lt;/configuration&gt;
</code></pre>
<p>以前的配置文件使用 <code>value</code> 加载以下键：</p>
<ul>
<li>key:attribute</li>
<li><code>section:key:attribute</code></li>
</ul>
<h4 id="Key-per-file-配置提供程序"><a href="#Key-per-file-配置提供程序" class="headerlink" title="Key-per-file 配置提供程序"></a>Key-per-file 配置提供程序</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.keyperfile.keyperfileconfigurationprovider">KeyPerFileConfigurationProvider</a> 使用目录的文件作为配置键值对。 该键是文件名。 该值包含文件的内容。 Key-per-file 配置提供程序用于 Docker 托管方案。</p>
<p>若要激活 Key-per-file 配置，请在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationbuilder">ConfigurationBuilder</a> 的实例上调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.keyperfileconfigurationbuilderextensions.addkeyperfile">AddKeyPerFile</a> 扩展方法。 文件的 <code>directoryPath</code> 必须是绝对路径。</p>
<p>重载允许指定：</p>
<ul>
<li>配置源的 <code>Action&lt;KeyPerFileConfigurationSource&gt;</code> 委托。</li>
<li>目录是否可选以及目录的路径。</li>
</ul>
<p>双下划线字符 (<code>__</code>) 用作文件名中的配置键分隔符。 例如，文件名 <code>Logging__LogLevel__System</code> 生成配置键 <code>Logging:LogLevel:System</code>。</p>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置：</p>
<pre><code class="csharp">.ConfigureAppConfiguration((hostingContext, config) =&gt;
&#123;
    var path = Path.Combine(
        Directory.GetCurrentDirectory(), &quot;path/to/files&quot;);
    config.AddKeyPerFile(directoryPath: path, optional: true);
&#125;)
</code></pre>
<h4 id="内存配置提供程序"><a href="#内存配置提供程序" class="headerlink" title="内存配置提供程序"></a>内存配置提供程序</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.memory.memoryconfigurationprovider">MemoryConfigurationProvider</a> 使用内存中集合作为配置键值对。</p>
<p>以下代码将内存集合添加到配置系统中：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args)
    &#123;
        var Dict = new Dictionary&lt;string, string&gt;
        &#123;
           &#123;&quot;MyKey&quot;, &quot;Dictionary MyKey Value&quot;&#125;,
           &#123;&quot;Position:Title&quot;, &quot;Dictionary_Title&quot;&#125;,
           &#123;&quot;Position:Name&quot;, &quot;Dictionary_Name&quot; &#125;,
           &#123;&quot;Logging:LogLevel:Default&quot;, &quot;Warning&quot;&#125;
        &#125;;

        return Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddInMemoryCollection(Dict);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
    &#125;
&#125;
</code></pre>
<p>以下来自<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>的代码显示了上述配置设置：</p>
<pre><code class="csharp">public class TestModel : PageModel
&#123;
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var myKeyValue = Configuration[&quot;MyKey&quot;];
        var title = Configuration[&quot;Position:Title&quot;];
        var name = Configuration[&quot;Position:Name&quot;];
        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];


        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \n&quot; +
                       $&quot;Title: &#123;title&#125; \n&quot; +
                       $&quot;Name: &#123;name&#125; \n&quot; +
                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>在前面的代码中，<code>config.AddInMemoryCollection(Dict)</code> 会被添加到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#default">默认配置提供程序</a>之后。 有关对配置提供程序进行排序的示例，请参阅 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#jcp">JSON 配置提供程序</a>。</p>
<p>有关使用 <code>MemoryConfigurationProvider</code> 的其他示例，请参阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1#boa">绑定数组</a>。</p>
<h4 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationbinder.getvalue">ConfigurationBinder.GetValue</a> 从配置中提取一个具有指定键的值，并将它转换为指定的类型。 此方法是 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a> 的扩展方法：</p>
<pre><code class="csharp">public class TestNumModel : PageModel
&#123;
    private readonly IConfiguration Configuration;

    public TestNumModel(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        var number = Configuration.GetValue&lt;int&gt;(&quot;NumberKey&quot;, 99);
        return Content($&quot;&#123;number&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>在前面的代码中，如果在配置中找不到 <code>NumberKey</code>，则使用默认值 <code>99</code>。</p>
<h4 id="GetSection、GetChildren-和-Exists"><a href="#GetSection、GetChildren-和-Exists" class="headerlink" title="GetSection、GetChildren 和 Exists"></a>GetSection、GetChildren 和 Exists</h4><p>对于下面的示例，请考虑以下 <code>MySubsection.json</code> 文件：</p>
<pre><code class="json">&#123;
  &quot;section0&quot;: &#123;
    &quot;key0&quot;: &quot;value00&quot;,
    &quot;key1&quot;: &quot;value01&quot;
  &#125;,
  &quot;section1&quot;: &#123;
    &quot;key0&quot;: &quot;value10&quot;,
    &quot;key1&quot;: &quot;value11&quot;
  &#125;,
  &quot;section2&quot;: &#123;
    &quot;subsection0&quot;: &#123;
      &quot;key0&quot;: &quot;value200&quot;,
      &quot;key1&quot;: &quot;value201&quot;
    &#125;,
    &quot;subsection1&quot;: &#123;
      &quot;key0&quot;: &quot;value210&quot;,
      &quot;key1&quot;: &quot;value211&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p>以下代码将 <code>MySubsection.json</code> 添加到配置提供程序：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddJsonFile(&quot;MySubsection.json&quot;, 
                    optional: true, 
                    reloadOnChange: true);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<h5 id="GetSection"><a href="#GetSection" class="headerlink" title="GetSection"></a>GetSection</h5><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfiguration.getsection">IConfiguration.GetSection</a> 会返回具有指定子节键的配置子节。</p>
<p>以下代码将返回 <code>section1</code> 的值：</p>
<pre><code class="csharp">public class TestSectionModel : PageModel
&#123;
    private readonly IConfiguration Config;

    public TestSectionModel(IConfiguration configuration)
    &#123;
        Config = configuration.GetSection(&quot;section1&quot;);
    &#125;

    public ContentResult OnGet()
    &#123;
        return Content(
                $&quot;section1:key0: &#39;&#123;Config[&quot;key0&quot;]&#125;&#39;\n&quot; +
                $&quot;section1:key1: &#39;&#123;Config[&quot;key1&quot;]&#125;&#39;&quot;);
    &#125;
&#125;
</code></pre>
<p>以下代码将返回 <code>section2:subsection0</code> 的值：</p>
<pre><code class="csharp">public class TestSection2Model : PageModel
&#123;
    private readonly IConfiguration Config;

    public TestSection2Model(IConfiguration configuration)
    &#123;
        Config = configuration.GetSection(&quot;section2:subsection0&quot;);
    &#125;

    public ContentResult OnGet()
    &#123;
        return Content(
                $&quot;section2:subsection0:key0 &#39;&#123;Config[&quot;key0&quot;]&#125;&#39;\n&quot; +
                $&quot;section2:subsection0:key1:&#39;&#123;Config[&quot;key1&quot;]&#125;&#39;&quot;);
    &#125;
&#125;
</code></pre>
<p><code>GetSection</code> 永远不会返回 <code>null</code>。 如果找不到匹配的节，则返回空 <code>IConfigurationSection</code>。</p>
<p>当 <code>GetSection</code> 返回匹配的部分时，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.value#microsoft-extensions-configuration-iconfigurationsection-value">Value</a> 未填充。 存在该部分时，返回一个 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.key#microsoft-extensions-configuration-iconfigurationsection-key">Key</a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.path#microsoft-extensions-configuration-iconfigurationsection-path">Path</a> 部分。</p>
<h5 id="GetChildren-和-Exists"><a href="#GetChildren-和-Exists" class="headerlink" title="GetChildren 和 Exists"></a>GetChildren 和 Exists</h5><p>以下代码将调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren">IConfiguration.GetChildren</a> 并返回 <code>section2:subsection0</code> 的值：</p>
<pre><code class="csharp">public class TestSection4Model : PageModel
&#123;
    private readonly IConfiguration Config;

    public TestSection4Model(IConfiguration configuration)
    &#123;
        Config = configuration;
    &#125;

    public ContentResult OnGet()
    &#123;
        string s = null;
        var selection = Config.GetSection(&quot;section2&quot;);
        if (!selection.Exists())
        &#123;
            throw new System.Exception(&quot;section2 does not exist.&quot;);
        &#125;
        var children = selection.GetChildren();

        foreach (var subSection in children)
        &#123;
            int i = 0;
            var key1 = subSection.Key + &quot;:key&quot; + i++.ToString();
            var key2 = subSection.Key + &quot;:key&quot; + i.ToString();
            s += key1 + &quot; value: &quot; + selection[key1] + &quot;\n&quot;;
            s += key2 + &quot; value: &quot; + selection[key2] + &quot;\n&quot;;
        &#125;
        return Content(s);
    &#125;
&#125;
</code></pre>
<p>前面的代码将调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationextensions.exists">ConfigurationExtensions.Exists</a> 以验证该节是否存在：</p>
<h4 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind">ConfigurationBinder.Bind</a> 支持使用配置键中的数组索引将数组绑定到对象。 公开数值键段的任何数组格式都能够与 <a target="_blank" rel="noopener" href="https://wikipedia.org/wiki/Plain_Old_CLR_Object">POCO</a> 类数组进行数组绑定。</p>
<p>请考虑<a target="_blank" rel="noopener" href="https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample">示例下载</a>中的 <code>MyArray.json</code>：</p>
<pre><code class="json">&#123;
  &quot;array&quot;: &#123;
    &quot;entries&quot;: &#123;
      &quot;0&quot;: &quot;value00&quot;,
      &quot;1&quot;: &quot;value10&quot;,
      &quot;2&quot;: &quot;value20&quot;,
      &quot;4&quot;: &quot;value40&quot;,
      &quot;5&quot;: &quot;value50&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<p>以下代码将 <code>MyArray.json</code> 添加到配置提供程序：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddJsonFile(&quot;MyArray.json&quot;, 
                    optional: true, 
                    reloadOnChange: true);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
&#125;
</code></pre>
<p>以下代码将读取配置并显示值：</p>
<pre><code class="csharp">public class ArrayModel : PageModel
&#123;
    private readonly IConfiguration Config;
    public ArrayExample _array &#123; get; private set; &#125;

    public ArrayModel(IConfiguration config)
    &#123;
        Config = config;
    &#125;

    public ContentResult OnGet()
    &#123;
        _array = Config.GetSection(&quot;array&quot;).Get&lt;ArrayExample&gt;();
        string s = null;

        for (int j = 0; j &lt; _array.Entries.Length; j++)
        &#123;
            s += $&quot;Index: &#123;j&#125;  Value:  &#123;_array.Entries[j]&#125; \n&quot;;
        &#125;

        return Content(s);
    &#125;
&#125;
</code></pre>
<p>前面的代码会返回以下输出：</p>
<pre><code class="text">Index: 0  Value: value00
Index: 1  Value: value10
Index: 2  Value: value20
Index: 3  Value: value40
Index: 4  Value: value50
</code></pre>
<p>在前面的输出中，索引 3 具有值 <code>value40</code>，与 <code>MyArray.json</code> 中的 <code>&quot;4&quot;: &quot;value40&quot;,</code> 相对应。 绑定的数组索引是连续的，并且未绑定到配置键索引。 配置绑定器不能绑定 NULL 值，也不能在绑定的对象中创建 NULL 条目</p>
<p>以下代码将通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.configuration.memoryconfigurationbuilderextensions.addinmemorycollection">AddInMemoryCollection</a> 扩展方法加载 <code>array:entries</code> 配置：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args)
    &#123;
        var arrayDict = new Dictionary&lt;string, string&gt;
        &#123;
            &#123;&quot;array:entries:0&quot;, &quot;value0&quot;&#125;,
            &#123;&quot;array:entries:1&quot;, &quot;value1&quot;&#125;,
            &#123;&quot;array:entries:2&quot;, &quot;value2&quot;&#125;,
            //              3   Skipped
            &#123;&quot;array:entries:4&quot;, &quot;value4&quot;&#125;,
            &#123;&quot;array:entries:5&quot;, &quot;value5&quot;&#125;
        &#125;;

        return Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddInMemoryCollection(arrayDict);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
    &#125;
&#125;
</code></pre>
<p>以下代码将读取 <code>arrayDict``Dictionary</code> 中的配置并显示值：</p>
<pre><code class="csharp">public class ArrayModel : PageModel
&#123;
    private readonly IConfiguration Config;
    public ArrayExample _array &#123; get; private set; &#125;

    public ArrayModel(IConfiguration config)
    &#123;
        Config = config;
    &#125;

    public ContentResult OnGet()
    &#123;
        _array = Config.GetSection(&quot;array&quot;).Get&lt;ArrayExample&gt;();
        string s = null;

        for (int j = 0; j &lt; _array.Entries.Length; j++)
        &#123;
            s += $&quot;Index: &#123;j&#125;  Value:  &#123;_array.Entries[j]&#125; \n&quot;;
        &#125;

        return Content(s);
    &#125;
&#125;
</code></pre>
<p>前面的代码会返回以下输出：</p>
<pre><code class="text">Index: 0  Value: value0
Index: 1  Value: value1
Index: 2  Value: value2
Index: 3  Value: value4
Index: 4  Value: value5
</code></pre>
<p>绑定对象中的索引 #3 保留 <code>array:4</code> 配置键的配置数据及其值 <code>value4</code>。 当绑定包含数组的配置数据时，配置键中的数组索引用于在创建对象时迭代配置数据。 无法在配置数据中保留 null 值，并且当配置键中的数组跳过一个或多个索引时，不会在绑定对象中创建 null 值条目。</p>
<p>可以在由任何读取索引 #3 键/值对的配置提供程序绑定到 <code>ArrayExample</code> 实例之前提供索引 #3 的缺失配置项。 请考虑示例下载中的以下 <code>Value3.json</code> 文件：</p>
<pre><code class="json">&#123;
  &quot;array:entries:3&quot;: &quot;value3&quot;
&#125;
</code></pre>
<p>以下代码包含 <code>Value3.json</code> 和 <code>arrayDict``Dictionary</code> 的配置：</p>
<pre><code class="csharp">public class Program
&#123;
    public static void Main(string[] args)
    &#123;
        CreateHostBuilder(args).Build().Run();
    &#125;

    public static IHostBuilder CreateHostBuilder(string[] args)
    &#123;
        var arrayDict = new Dictionary&lt;string, string&gt;
        &#123;
            &#123;&quot;array:entries:0&quot;, &quot;value0&quot;&#125;,
            &#123;&quot;array:entries:1&quot;, &quot;value1&quot;&#125;,
            &#123;&quot;array:entries:2&quot;, &quot;value2&quot;&#125;,
            //              3   Skipped
            &#123;&quot;array:entries:4&quot;, &quot;value4&quot;&#125;,
            &#123;&quot;array:entries:5&quot;, &quot;value5&quot;&#125;
        &#125;;

        return Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) =&gt;
            &#123;
                config.AddInMemoryCollection(arrayDict);
                config.AddJsonFile(&quot;Value3.json&quot;,
                                    optional: false, reloadOnChange: false);
            &#125;)
            .ConfigureWebHostDefaults(webBuilder =&gt;
            &#123;
                webBuilder.UseStartup&lt;Startup&gt;();
            &#125;);
    &#125;
&#125;
</code></pre>
<p>以下代码将读取上述配置并显示值：</p>
<pre><code class="csharp">public class ArrayModel : PageModel
&#123;
    private readonly IConfiguration Config;
    public ArrayExample _array &#123; get; private set; &#125;

    public ArrayModel(IConfiguration config)
    &#123;
        Config = config;
    &#125;

    public ContentResult OnGet()
    &#123;
        _array = Config.GetSection(&quot;array&quot;).Get&lt;ArrayExample&gt;();
        string s = null;

        for (int j = 0; j &lt; _array.Entries.Length; j++)
        &#123;
            s += $&quot;Index: &#123;j&#125;  Value:  &#123;_array.Entries[j]&#125; \n&quot;;
        &#125;

        return Content(s);
    &#125;
&#125;
</code></pre>
<p>前面的代码会返回以下输出：</p>
<pre><code class="text">Index: 0  Value: value0
Index: 1  Value: value1
Index: 2  Value: value2
Index: 3  Value: value3
Index: 4  Value: value4
Index: 5  Value: value5
</code></pre>
<p>不需要自定义配置提供程序实现数组绑定。</p>
<h4 id="自定义配置提供程序-TODO"><a href="#自定义配置提供程序-TODO" class="headerlink" title="自定义配置提供程序==TODO=="></a>自定义配置提供程序==TODO==</h4><h4 id="访问-Startup-中的配置"><a href="#访问-Startup-中的配置" class="headerlink" title="访问 Startup 中的配置"></a>访问 Startup 中的配置</h4><p>以下代码显示 <code>Startup</code> 方法中的配置数据：</p>
<pre><code class="csharp">public class Startup
&#123;
    public Startup(IConfiguration configuration)
    &#123;
        Configuration = configuration;
    &#125;

    public IConfiguration Configuration &#123; get; &#125;

    public void ConfigureServices(IServiceCollection services)
    &#123;
        services.AddRazorPages();
        Console.WriteLine($&quot;MyKey : &#123;Configuration[&quot;MyKey&quot;]&#125;&quot;);
    &#125;

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    &#123;
        Console.WriteLine($&quot;Position:Title : &#123;Configuration[&quot;Position:Title&quot;]&#125;&quot;);

        if (env.IsDevelopment())
        &#123;
            app.UseDeveloperExceptionPage();
        &#125;
        else
        &#123;
            app.UseExceptionHandler(&quot;/Error&quot;);
            app.UseHsts();
        &#125;

        app.UseHttpsRedirection();
        app.UseStaticFiles();

        app.UseRouting();

        app.UseAuthorization();

        app.UseEndpoints(endpoints =&gt;
        &#123;
            endpoints.MapRazorPages();
        &#125;);
    &#125;
&#125;
</code></pre>
<p>有关使用启动便捷方法访问配置的示例，请参阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/startup?view=aspnetcore-3.1#convenience-methods">应用启动：便捷方法</a>。</p>
<h4 id="访问-Razor-Pages-中的配置"><a href="#访问-Razor-Pages-中的配置" class="headerlink" title="访问 Razor Pages 中的配置"></a>访问 Razor Pages 中的配置</h4><p>以下代码显示 Razor Pages 中的配置数据：</p>
<pre><code class="cshtml">@page
@model Test5Model
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration

Configuration value for &#39;MyKey&#39;: @Configuration[&quot;MyKey&quot;]
</code></pre>
<p>在以下代码中，<code>MyOptions</code> 已通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.dependencyinjection.optionsconfigurationservicecollectionextensions.configure">Configure</a> 被添加到了服务容器并已绑定到了配置：</p>
<pre><code class="csharp">public void ConfigureServices(IServiceCollection services)
&#123;
    services.Configure&lt;MyOptions&gt;(Configuration.GetSection(&quot;MyOptions&quot;));

    services.AddRazorPages();
&#125;
</code></pre>
<p>以下标记使用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-3.1#inject"><code>@inject</code></a>Razor 指令来解析和显示选项值：</p>
<pre><code class="cshtml">@page
@model SampleApp.Pages.Test3Model
@using Microsoft.Extensions.Options
@inject IOptions&lt;MyOptions&gt; optionsAccessor


&lt;p&gt;&lt;b&gt;Option1:&lt;/b&gt; @optionsAccessor.Value.Option1&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Option2:&lt;/b&gt; @optionsAccessor.Value.Option2&lt;/p&gt;
</code></pre>
<p><img src="/2022/07/07/2022-07-07/image-20220707172500003.png" alt="image-20220707172500003"></p>
<p><img src="/2022/07/07/2022-07-07/image-20220707172526886.png" alt="image-20220707172526886"></p>
<p><img src="/2022/07/07/2022-07-07/image-20220707172625707.png" alt="image-20220707172625707"></p>
<h4 id="访问-MVC-视图文件中的配置"><a href="#访问-MVC-视图文件中的配置" class="headerlink" title="访问 MVC 视图文件中的配置"></a>访问 MVC 视图文件中的配置</h4><p>以下代码显示 MVC 视图中的配置数据：</p>
<pre><code class="cshtml">@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration

Configuration value for &#39;MyKey&#39;: @Configuration[&quot;MyKey&quot;]
</code></pre>
<h4 id="使用委托来配置选项"><a href="#使用委托来配置选项" class="headerlink" title="使用委托来配置选项"></a>使用委托来配置选项</h4><p>在委托中配置的选项替代在配置提供程序中设置的值。</p>
<p>示例应用中的示例 2 展示了如何使用委托来配置选项。</p>
<p>在以下代码中，向服务容器添加了 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/dotnet/api/microsoft.extensions.options.iconfigureoptions-1">IConfigureOptions</a> 服务。 它使用委托来配置 <code>MyOptions</code> 的值：</p>
<pre><code class="csharp">public void ConfigureServices(IServiceCollection services)
&#123;
    services.Configure&lt;MyOptions&gt;(myOptions =&gt;
    &#123;
        myOptions.Option1 = &quot;Value configured in delegate&quot;;
        myOptions.Option2 = 500;
    &#125;);

    services.AddRazorPages();
&#125;
</code></pre>
<p>以下代码显示选项值：</p>
<pre><code class="csharp">public class Test2Model : PageModel
&#123;
    private readonly IOptions&lt;MyOptions&gt; _optionsDelegate;

    public Test2Model(IOptions&lt;MyOptions&gt; optionsDelegate )
    &#123;
        _optionsDelegate = optionsDelegate;
    &#125;

    public ContentResult OnGet()
    &#123;
        return Content($&quot;Option1: &#123;_optionsDelegate.Value.Option1&#125; \n&quot; +
                       $&quot;Option2: &#123;_optionsDelegate.Value.Option2&#125;&quot;);
    &#125;
&#125;
</code></pre>
<p>在前面的示例中，<code>Option1</code> 和 <code>Option2</code> 的值在 <code>appsettings.json</code> 中指定，然后被配置的委托替代。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>[使用选项模式绑定分层配置数据](#### 使用选项模式绑定分层配置数据)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zicl1.github.io/2022/07/07/2022-07-07/" data-id="clzjk1e2n000mmcr97o4u8f7z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Life/" rel="tag">Life</a></li></ul>

    </footer>
  </div>
  
    
    
    <div id="my-container"></div>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script>
    var gitment = new Gitment({
      id: '2022年07月07日', // 可选。默认为 location.href, 现在改为页面的标题https://hexo.io/zh-cn/docs/variables.html
      owner: 'zicl1',
      repo: 'discuss',
      oauth: {
        client_id: '41bf782a65aabaed603c',
        client_secret: '008c8b70c4aa044a21d8752b9df92799dd327fef',
      },
    })
    gitment.render('my-container')
    </script>
    
    
<nav id="article-nav">
  
    <a href="/2022/07/08/2022-07-08/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2022年07月08日
        
      </div>
    </a>
  
  
    <a href="/2022/07/06/2022-07-06/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2022年07月06日</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NET/" rel="tag">.NET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Download/" rel="tag">Download</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/" rel="tag">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PAT/" rel="tag">PAT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Personal-website/" rel="tag">Personal website</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/Download/" style="font-size: 15px;">Download</a> <a href="/tags/Life/" style="font-size: 20px;">Life</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/PAT/" style="font-size: 10px;">PAT</a> <a href="/tags/Personal-website/" style="font-size: 10px;">Personal website</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/01/2024-06-01/">2024年06月01日</a>
          </li>
        
          <li>
            <a href="/2024/05/25/2024-05-25/">2024年05月25日</a>
          </li>
        
          <li>
            <a href="/2024/05/18/2024-05-18/">2024年05月18日</a>
          </li>
        
          <li>
            <a href="/2024/05/12/2024-05-12/">2024年05月12日</a>
          </li>
        
          <li>
            <a href="/2024/05/02/2024-05-02/">2024年05月02日</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022-2024 Zichen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/" target="_blank">Github</a> <a href="https://ibruce.info/" target="_blank">不蒜子</a> <br>
      <span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</span>
      <span id="busuanzi_container_site_uv">本站访客数 <span id="busuanzi_value_site_uv"></span> 人次
      <br/>
      <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001" target="_blank">
        <img width="13px" src="/css/images/gongan.png"/>
        京公网安备 11000002000001 号
      </a> &nbsp;
      <a href="https://beian.miit.gov.cn/" target="_blank"> 京ICP证030173号 </a>
      </span>
      <br/>
      建议您使用Edge、Chrome 80+、FireFox 86+、360极速模式等主流浏览器浏览本网站
    </div>
  </div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>